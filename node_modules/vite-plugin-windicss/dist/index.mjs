var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __exportStar = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  if (module && module.__esModule)
    return module;
  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", {value: module, enumerable: true})), module);
};

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self = debug2;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var {formatters} = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  "use strict";
  module.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  "use strict";
  var os = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = require("tty");
  var util = require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug2) {
    debug2.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var {formatters} = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// src/index.ts
var import_debug2 = __toModule(require_src());

// src/box/index.ts
var import_debug = __toModule(require_src());
import {promises as fs, existsSync} from "fs";
import {join, resolve, relative} from "path";
import WindiCssProcessor from "windicss";
import {StyleSheet} from "windicss/utils/style";
import {CSSParser} from "windicss/utils/parser";
import fg from "fast-glob";
import micromatch from "micromatch";

// src/box/constants.ts
var regexQuotedString = /(["'`])((?:\\\1|(?:(?!\1)|\n).)*?)\1/mg;
var regexClassCheck = /^[a-z.-]+[\w:/\\.$-]*\w$/;
var regexHtmlTag = /<(\w[\w-]*)/g;
var regexClassSplitter = /[\s'"`{}]/g;
var regexClassGroup = /(\w[\w:_/-]*?):\(([\w\s/-]*?)\)/gm;
var defaultAlias = {
  "router-link": "a"
};
var preflightTags = ["html", "body", "div"];
var htmlTags = [
  "html",
  "body",
  "div",
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "base",
  "basefont",
  "bdo",
  "blink",
  "blockquote",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "col",
  "colgroup",
  "command",
  "comment",
  "datalist",
  "dd",
  "del",
  "details",
  "dir",
  "dl",
  "dt",
  "embed",
  "fieldset",
  "figure",
  "b",
  "big",
  "i",
  "small",
  "tt",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "head",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "isindex",
  "iframe",
  "ilayer",
  "img",
  "input",
  "ins",
  "keygen",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "cite",
  "code",
  "dfn",
  "em",
  "kbd",
  "samp",
  "strong",
  "var",
  "plaintext",
  "pre",
  "progress",
  "q",
  "ruby",
  "script",
  "section",
  "select",
  "spacer",
  "span",
  "s",
  "strike",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "u",
  "ul",
  "video",
  "wbr",
  "wbr",
  "xmp"
];

// src/box/utils.ts
function toArray(v) {
  if (Array.isArray(v))
    return v;
  return [v];
}
function slash(str) {
  return str.replace(/\\/g, "/");
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function include(set, v) {
  for (const i of v)
    set.add(i);
}
function exclude(set, v) {
  for (const i of v)
    set.delete(i);
}
function transfromGroups(str) {
  return str.replace(regexClassGroup, (_, a, b) => b.split(/\s/g).map((i) => `${a}:${i}`).join(" "));
}

// src/box/options.ts
function resolveOptions(options) {
  const {
    config = "tailwind.config.js",
    scan = true,
    preflight = true,
    transformCSS = true,
    sortUtilities = true,
    root = process.cwd()
  } = options;
  const preflightOptions = Object.assign({
    includeBase: true,
    includeGlobal: true,
    includePlugin: true,
    enableAll: false,
    alias: {}
  }, typeof preflight === "boolean" ? {} : preflight);
  const scanOptions = Object.assign({
    fileExtensions: ["html", "vue", "md", "pug", "jsx", "tsx", "svelte"],
    dirs: ["src"],
    exclude: [],
    include: [],
    runOnStartup: true
  }, typeof scan === "boolean" ? {} : scan);
  const safelist = new Set(toArray(options.safelist || []).flatMap((i) => i.split(" ")));
  preflightOptions.alias = Object.fromEntries(Object.entries(__assign(__assign({}, defaultAlias), preflightOptions.alias)).filter(([k, v]) => [kebabCase(k), v]));
  return __assign(__assign({}, options), {
    config,
    scan: Boolean(scan),
    scanOptions,
    preflight: Boolean(preflight),
    preflightOptions,
    transformCSS,
    sortUtilities,
    safelist,
    root
  });
}

// src/box/index.ts
function createBox(_options = {}) {
  const options = resolveOptions(_options);
  const {
    name,
    config,
    scan: enabledScan,
    scanOptions,
    transformCSS: enableCssTransform,
    preflight: enablePreflight,
    preflightOptions,
    sortUtilities,
    root,
    safelist
  } = options;
  const debug2 = {
    config: import_debug.default(`${name}:config`),
    debug: import_debug.default(`${name}:debug`),
    compile: import_debug.default(`${name}:compile`),
    glob: import_debug.default(`${name}:glob`),
    detect: import_debug.default(`${name}:detect`)
  };
  let processor;
  let configFilePath;
  const globs = getGlobs();
  const excludeGlobs = getExcludeGlob();
  const files = [];
  const regexId = new RegExp(`\\.(?:${scanOptions.fileExtensions.join("|")})$`, "i");
  const configSafelist = new Set();
  const classesGenerated = new Set();
  const classesPending = new Set();
  const tagsGenerated = new Set();
  const tagsPending = new Set();
  const tagsAvailable = new Set();
  function loadConfiguration() {
    var _a, _b, _c, _d;
    let resolved = {};
    if (typeof config === "string") {
      const path = resolve(root, config);
      if (!existsSync(path)) {
        console.warn(`[${name}] config file "${config}" not found, ignored`);
      } else {
        try {
          delete require.cache[require.resolve(path)];
          resolved = require(path);
          configFilePath = path;
          configSafelist.clear();
          include(configSafelist, ((_b = (_a = resolved == null ? void 0 : resolved.purge) == null ? void 0 : _a.options) == null ? void 0 : _b.safelist) || ((_d = (_c = resolved == null ? void 0 : resolved.purge) == null ? void 0 : _c.options) == null ? void 0 : _d.whitelist) || []);
        } catch (e) {
          console.error(`[${name}] failed to load config "${config}"`);
          console.error(`[${name}] ${e.toString()}`);
          process.exit(1);
        }
      }
    } else {
      resolved = config;
    }
    debug2.config(JSON.stringify(resolved, null, 2));
    return resolved;
  }
  function initWindicss() {
    return new WindiCssProcessor(loadConfiguration());
  }
  function getGlobs() {
    const {dirs, fileExtensions, include: include2} = scanOptions;
    const globs2 = dirs.map((i) => slash(join(i, `**/*.{${fileExtensions.join(",")}}`)));
    globs2.unshift("index.html");
    globs2.unshift(...include2);
    debug2.glob("globs", globs2);
    return globs2;
  }
  function getExcludeGlob() {
    return ["node_modules", ".git", ...scanOptions.exclude];
  }
  async function getFiles() {
    const files2 = await fg(globs, {
      cwd: root,
      ignore: excludeGlobs,
      onlyFiles: true,
      absolute: true
    });
    files2.sort();
    debug2.glob("files", files2);
    return files2;
  }
  let scanned = false;
  let _searching;
  async function scan() {
    if (!_searching) {
      _searching = (async () => {
        files.push(...await getFiles());
        const contents = await Promise.all(files.filter((id) => isDetectTarget(id)).map((id) => fs.readFile(id, "utf-8")));
        for (const content of contents)
          extractFile(content);
        scanned = true;
      })();
    }
    return _searching;
  }
  function isExcluded(id) {
    return id.match(/\b(?:node_modules|.git)\b/) || micromatch.isMatch(slash(relative(root, id)), excludeGlobs);
  }
  function isDetectTarget(id) {
    return id.match(regexId) && !isExcluded(id);
  }
  function isScanTarget(id) {
    return enabledScan ? files.some((file) => id.startsWith(file)) : isDetectTarget(id);
  }
  function isCssTransformTarget(id) {
    if (id.match(/\.(?:postcss|scss|sass|css|stylus)(?:$|\?)/i) && !isExcluded(id))
      return true;
    return false;
  }
  function extractFile(code) {
    Array.from(code.matchAll(regexQuotedString)).flatMap((m) => (m[2] || "").replace(regexClassGroup, (v) => {
      if (!classesGenerated.has(v))
        classesPending.add(v);
      return "";
    }).split(regexClassSplitter)).filter((i) => i.match(regexClassCheck)).forEach((i) => {
      if (!i || classesGenerated.has(i))
        return;
      classesPending.add(i);
    });
    if (enablePreflight || !preflightOptions.enableAll) {
      Array.from(code.matchAll(regexHtmlTag)).flatMap(([, i]) => i).forEach((i) => {
        if (!tagsAvailable.has(i))
          i = preflightOptions.alias[kebabCase(i)];
        if (!tagsAvailable.has(i))
          return;
        tagsPending.add(i);
        tagsAvailable.delete(i);
      });
    }
    debug2.detect("classes", classesPending);
    debug2.detect("tags", tagsPending);
  }
  function transformCSS(css) {
    if (!enableCssTransform)
      return css;
    const style2 = new CSSParser(css, processor).parse();
    return style2.build();
  }
  let style = new StyleSheet();
  let _cssCache;
  async function generateCSS() {
    if (enabledScan && scanOptions.runOnStartup)
      await scan();
    let changed = false;
    if (classesPending.size) {
      const result = processor.interpret(Array.from(classesPending).join(" "));
      if (result.success.length) {
        include(classesGenerated, result.success);
        classesPending.clear();
        debug2.compile(`compiled ${result.success.length} classes`);
        debug2.compile(result.success);
        style = style.extend(result.styleSheet);
        changed = true;
      }
    }
    if (enablePreflight) {
      if (preflightOptions.enableAll || tagsPending.size) {
        const preflightStyle = processor.preflight(preflightOptions.enableAll ? void 0 : Array.from(tagsPending).map((i) => `<${i}`).join(" "), preflightOptions.includeBase, preflightOptions.includeGlobal, preflightOptions.includePlugin);
        style = style.extend(preflightStyle, true);
        include(tagsGenerated, tagsPending);
        tagsPending.clear();
        changed = true;
      }
    }
    if (changed || !_cssCache) {
      if (sortUtilities)
        style.sort();
      _cssCache = style.build();
    }
    return _cssCache;
  }
  function clearCache() {
    style = new StyleSheet();
    _cssCache = void 0;
    const preflightSafelist = toArray((preflightOptions == null ? void 0 : preflightOptions.safelist) || []).flatMap((i) => i.split(" "));
    include(classesPending, configSafelist);
    include(classesPending, safelist);
    include(classesPending, classesGenerated);
    include(tagsPending, tagsGenerated);
    include(tagsPending, preflightTags);
    include(tagsPending, preflightSafelist);
    include(tagsAvailable, htmlTags);
    exclude(tagsAvailable, preflightTags);
    exclude(tagsAvailable, preflightSafelist);
    classesGenerated.clear();
    tagsGenerated.clear();
  }
  function init() {
    processor = initWindicss();
    clearCache();
  }
  return {
    options,
    init,
    extractFile,
    generateCSS,
    clearCache,
    transformCSS,
    isDetectTarget,
    isScanTarget,
    isCssTransformTarget,
    scan,
    files,
    globs,
    classesGenerated,
    classesPending,
    tagsGenerated,
    tagsPending,
    tagsAvailable,
    get scanned() {
      return scanned;
    },
    get configFilePath() {
      return configFilePath;
    }
  };
}

// src/index.ts
var NAME = "vite-plugin-windicss";
var MODULE_ID = "windi.css";
var MODULE_ID_VIRTUAL = `/@windicss/${MODULE_ID}`;
var debug = {
  hmr: import_debug2.default(`${NAME}:hmr`),
  css: import_debug2.default(`${NAME}:transform:css`),
  group: import_debug2.default(`${NAME}:transform:group`)
};
function VitePluginWindicss(options = {}) {
  let box;
  const plugins = [];
  if (options.transformGroups !== false) {
    plugins.push({
      name: `${NAME}:groups`,
      transform(code, id) {
        if (!box.isScanTarget(id))
          return;
        debug.group(id);
        return transfromGroups(code);
      }
    });
  }
  plugins.push({
    name: `${NAME}:pre`,
    enforce: "pre",
    configResolved(_config) {
      box = createBox(__assign(__assign({}, options), {
        name: NAME,
        root: _config.root
      }));
      box.init();
    },
    resolveId(id) {
      return id.startsWith(MODULE_ID) || id === MODULE_ID_VIRTUAL ? MODULE_ID_VIRTUAL : null;
    },
    async load(id) {
      if (id === MODULE_ID_VIRTUAL)
        return box.generateCSS();
    }
  });
  plugins.push({
    name: `${NAME}:hmr`,
    apply: "serve",
    enforce: "post",
    configureServer(server) {
      if (box.configFilePath)
        server.watcher.add(box.configFilePath);
    },
    async handleHotUpdate({server, file, read, modules}) {
      if (file === box.configFilePath) {
        debug.hmr(`config file changed: ${file}`);
        box.init();
        setTimeout(() => {
          console.log(`[${NAME}] configure file changed, reloading`);
          server.ws.send({type: "full-reload"});
        }, 0);
        return [server.moduleGraph.getModuleById(MODULE_ID_VIRTUAL)];
      }
      if (!box.isDetectTarget(file))
        return;
      debug.hmr(`refreshed by ${file}`);
      box.extractFile(await read());
      const module = server.moduleGraph.getModuleById(MODULE_ID_VIRTUAL);
      server.moduleGraph.invalidateModule(module);
      if (file.endsWith(".html"))
        return void 0;
      return [module, ...modules];
    }
  });
  if (options.transformCSS !== false) {
    plugins.push({
      name: `${NAME}:css`,
      transform(code, id) {
        if (!box.isCssTransformTarget(id))
          return;
        debug.css(id);
        return box.transformCSS(code);
      }
    });
  }
  return plugins;
}
var src_default = VitePluginWindicss;
export {
  createBox,
  src_default as default,
  defaultAlias,
  htmlTags,
  preflightTags
};
